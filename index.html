<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DULMUNG BLAST Puzzle Game</title>
    <style>
        :root {
            /* 8 Rows x 9 Columns Grid Settings */
            --grid-rows: 8;
            --grid-cols: 9;
            --cell-size: 40px; 
            --preview-size: 100px; /* Size for block preview area */
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: sans-serif;
            color: #333;
        }

        h1 {
            color: #4a4a4a;
        }

        #main-wrapper {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        #game-container {
            position: relative;
        }

        #game-board {
            display: grid;
            grid-template-rows: repeat(var(--grid-rows), var(--cell-size));
            grid-template-columns: repeat(var(--grid-cols), var(--cell-size));
            border: 3px solid #333;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            background-color: #ccc; /* Board background gray */
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            box-sizing: border-box;
            border: 1px solid #999;
        }

        /* Block colors */
        .block-white {
            background-color: white;
            border: 1px solid #666;
        }
        
        .block-black {
            background-color: black;
            border: 1px solid #fff;
        }
        
        .block-gray {
            background-color: gray;
            border: 1px solid #333;
        }

        #status-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 150px;
            max-height: 150px;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none; /* Make image unclickable */
        }

        #status-image.visible {
            opacity: 1;
        }

        #score-board {
            margin-bottom: 20px;
            font-size: 1.5em;
            font-weight: bold;
        }

        #preview-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #eee;
        }

        .block-preview {
            width: var(--preview-size);
            height: var(--preview-size);
            border: 2px solid #666;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #fff;
            cursor: grab;
            user-select: none;
        }
        
        .block-preview.empty {
            background-color: #ddd;
            border-style: dashed;
            cursor: default;
        }

        .block-shape {
            display: inline-grid;
            gap: 1px;
            padding: 5px; /* Padding for better visibility */
            background-color: rgba(0, 0, 0, 0.1);
        }

        .block-shape .block-part {
            width: 15px;
            height: 15px;
            box-sizing: border-box;
        }

        button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <h1>DULMUNG BLAST</h1>
    <div id="score-board">Score: <span id="current-score">0</span> | High Score: <span id="high-score">0</span></div>
    
    <div id="main-wrapper">
        <div id="game-container">
            <div id="game-board" 
                 ondragover="handleBoardDragOver(event)" 
                 ondrop="handleBoardDrop(event)">
                </div>
            <img id="status-image" src="" alt="Game Status Image">
        </div>

        <div id="preview-area">
            </div>
    </div>
    

    <button onclick="startGame()">Start / Restart Game</button>

    <script>
        // --- Game Configuration ---
        const ROWS = 8;
        const COLS = 9;
        const CELL_COLORS = ['block-white', 'block-black', 'block-gray'];
        const SLEEP_TIMEOUT = 30000; // 30 seconds for '잠.png'

        // Define Block Shapes (1 represents a solid block part)
        // These are standard 1010! / Block Blast shapes
        const BLOCK_SHAPES_DATA = [
            { id: 1, color: 'block-white', shape: [[1, 1, 1, 1]] }, // 1x4 line
            { id: 2, color: 'block-black', shape: [[1], [1], [1]] }, // 3x1 line
            { id: 3, color: 'block-gray', shape: [[1, 1], [1, 1]] }, // 2x2 square
            { id: 4, color: 'block-white', shape: [[1, 0], [1, 0], [1, 1]] }, // L shape
            { id: 5, color: 'block-black', shape: [[1, 1, 1], [0, 1, 0]] }, // T shape
            { id: 6, color: 'block-gray', shape: [[1, 1, 1]] }, // 1x3 line
            { id: 7, color: 'block-white', shape: [[1, 1]] }, // 1x2 line
            { id: 8, color: 'block-black', shape: [[1]] }, // 1x1 block
            { id: 9, color: 'block-gray', shape: [[1, 1, 1], [1, 0, 0], [1, 0, 0]] }, // Large L
        ];

        // --- DOM Elements ---
        const gameBoard = document.getElementById('game-board');
        const statusImage = document.getElementById('status-image');
        const currentScoreElement = document.getElementById('current-score');
        const highScoreElement = document.getElementById('high-score');
        const previewArea = document.getElementById('preview-area');

        // --- Game State Variables ---
        let board = []; // 2D array to hold block data (0: empty, 1/2/3: colored blocks)
        let score = 0;
        let highScore = localStorage.getItem('dulmungBlastHighScore') || 0;
        let lastMoveTime = Date.now();
        let sleepTimer = null;
        let comboCount = 0;
        let currentBlockSet = []; // Array of 3 blocks
        let currentDraggingBlock = null;

        highScoreElement.textContent = highScore;

        // --- Utility Functions ---

        /** Generates a random block shape */
        function generateBlock() {
            const randomIndex = Math.floor(Math.random() * BLOCK_SHAPES_DATA.length);
            return { ...BLOCK_SHAPES_DATA[randomIndex] };
        }

        /** Draws the given shape onto the preview element */
        function drawPreviewBlock(element, shapeData) {
            element.innerHTML = '';
            
            const shapeDiv = document.createElement('div');
            shapeDiv.classList.add('block-shape');
            
            // Set grid template based on shape dimensions
            const rows = shapeData.shape.length;
            const cols = shapeData.shape[0].length;
            
            shapeDiv.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            shapeDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const blockPart = document.createElement('div');
                    blockPart.classList.add('block-part');
                    if (shapeData.shape[r][c] === 1) {
                        blockPart.classList.add(shapeData.color);
                    }
                    shapeDiv.appendChild(blockPart);
                }
            }
            element.appendChild(shapeDiv);
        }

        // --- Game Core Functions ---

        /** Creates the 8x9 grid DOM elements */
        function createBoard() {
            gameBoard.innerHTML = '';
            board = Array(ROWS).fill(0).map(() => Array(COLS).fill(0)); 
            
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    gameBoard.appendChild(cell);
                }
            }
        }
        
        /** Updates the visual display of the board based on the 'board' data array */
        function updateBoardDisplay() {
            const cells = gameBoard.querySelectorAll('.cell');
            cells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                const blockType = board[r][c];
                
                CELL_COLORS.forEach(color => cell.classList.remove(color));

                if (blockType > 0) {
                    cell.classList.add(CELL_COLORS[blockType - 1]);
                }
            });
        }
        
        /** Generates and displays 3 new blocks */
        function generateNewBlockSet() {
            previewArea.innerHTML = '';
            currentBlockSet = [];

            for (let i = 0; i < 3; i++) {
                const blockData = generateBlock();
                currentBlockSet.push(blockData);

                const previewElement = document.createElement('div');
                previewElement.classList.add('block-preview');
                previewElement.id = `preview-${i}`;
                previewElement.draggable = true;
                
                // Store block data in dataset for drag operation
                previewElement.dataset.index = i;
                previewElement.dataset.shape = JSON.stringify(blockData.shape);
                previewElement.dataset.color = blockData.color;
                
                drawPreviewBlock(previewElement, blockData);

                previewElement.addEventListener('dragstart', handleBlockDragStart);
                previewArea.appendChild(previewElement);
            }
        }
        
        /** Checks if the block fits and updates the board array */
        function attemptPlacement(startRow, startCol, blockData) {
            const shape = blockData.shape;
            const rows = shape.length;
            const cols = shape[0].length;
            const colorIndex = CELL_COLORS.indexOf(blockData.color) + 1; // 1, 2, or 3

            // 1. Check for boundaries and collisions
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (shape[r][c] === 1) {
                        const boardRow = startRow + r;
                        const boardCol = startCol + c;

                        // Check bounds and if cell is already occupied
                        if (boardRow >= ROWS || boardRow < 0 || boardCol >= COLS || boardCol < 0 || board[boardRow][boardCol] !== 0) {
                            return false; // Placement failed (out of bounds or collision)
                        }
                    }
                }
            }

            // 2. Place the block (Update the board array)
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (shape[r][c] === 1) {
                        board[startRow + r][startCol + c] = colorIndex;
                    }
                }
            }
            return true; // Placement successful
        }
        
        /** Checks for complete rows/columns and clears them, returning the count */
        function checkAndClearLines() {
            let clearedCount = 0;
            const linesToClear = [];

            // Check Rows
            for (let r = 0; r < ROWS; r++) {
                if (board[r].every(cell => cell !== 0)) {
                    linesToClear.push({ type: 'row', index: r });
                }
            }

            // Check Columns
            for (let c = 0; c < COLS; c++) {
                let isFull = true;
                for (let r = 0; r < ROWS; r++) {
                    if (board[r][c] === 0) {
                        isFull = false;
                        break;
                    }
                }
                // Prevent duplicate clearing if a cell is part of both a full row and a full column
                if (isFull && !linesToClear.some(l => l.type === 'col' && l.index === c)) {
                    linesToClear.push({ type: 'col', index: c });
                }
            }
            
            // Clear the lines
            linesToClear.forEach(line => {
                clearedCount++;
                if (line.type === 'row') {
                    board[line.index].fill(0);
                } else if (line.type === 'col') {
                    for (let r = 0; r < ROWS; r++) {
                        board[r][line.index] = 0;
                    }
                }
            });

            return clearedCount;
        }

        /** Checks if any of the remaining blocks can be placed anywhere on the board */
        function checkGameOverCondition() {
            // Check only the blocks that haven't been placed yet
            for (const blockData of currentBlockSet) {
                if (blockData) {
                    const shape = blockData.shape;
                    const rows = shape.length;
                    const cols = shape[0].length;
                    
                    // Iterate through every cell on the board as a potential top-left corner
                    for (let r = 0; r <= ROWS - rows; r++) {
                        for (let c = 0; c <= COLS - cols; c++) {
                            
                            // Check if the block fits at position (r, c)
                            let fits = true;
                            for (let br = 0; br < rows; br++) {
                                for (let bc = 0; bc < cols; bc++) {
                                    if (shape[br][bc] === 1) {
                                        // Check collision against existing blocks
                                        if (board[r + br][c + bc] !== 0) {
                                            fits = false;
                                            break;
                                        }
                                    }
                                }
                                if (!fits) break;
                            }
                            if (fits) {
                                return false; // At least one block can still be placed
                            }
                        }
                    }
                }
            }

            // Only check for game over if all 3 blocks are currently on the board and can't be placed
            if (currentBlockSet.every(block => block === null) && previewArea.children.length === 0) {
                // If the set is empty, it means new blocks should have been generated. 
                // This state should ideally not happen unless game logic is flawed or the game is over 
                // and new blocks couldn't be generated.
                return false; 
            } else if (currentBlockSet.some(block => block !== null)) {
                // If there are unplaced blocks, and none of them fit, it's game over.
                return true;
            }

            return false;
        }
        
        // --- Event Handlers ---

        function handleBlockDragStart(event) {
            if (event.target.classList.contains('empty')) return;
            
            // Store block data and its index for later removal
            currentDraggingBlock = {
                index: parseInt(event.target.dataset.index),
                shape: JSON.parse(event.target.dataset.shape),
                color: event.target.dataset.color
            };
            event.dataTransfer.setData('text/plain', '');
            
            resetInactivityTimer();
        }

        function handleBoardDragOver(event) {
            event.preventDefault(); 
        }

        function handleBoardDrop(event) {
            event.preventDefault();

            if (!currentDraggingBlock) return;

            const targetCell = event.target.closest('.cell');
            if (!targetCell) return;
            
            const startRow = parseInt(targetCell.dataset.row);
            const startCol = parseInt(targetCell.dataset.col);

            const blockData = currentDraggingBlock;

            const placementSuccessful = attemptPlacement(startRow, startCol, blockData);

            if (placementSuccessful) {
                // 1. Mark block as placed and visually remove it
                const placedBlockIndex = blockData.index;
                currentBlockSet[placedBlockIndex] = null;
                document.getElementById(`preview-${placedBlockIndex}`).classList.add('empty');
                document.getElementById(`preview-${placedBlockIndex}`).draggable = false;
                document.getElementById(`preview-${placedBlockIndex}`).innerHTML = '';
                
                // 2. Check for cleared lines and combos
                const clearedLines = checkAndClearLines(); 
                let isCombo = clearedLines > 0;
                
                if (isCombo) {
                    const newScore = score + (clearedLines * 10) + (comboCount * 5); // Combo bonus score
                    handleCombo(true, newScore); 
                } else {
                    // Successful move, but no line cleared. Reset combo count.
                    handleCombo(false, score + 1); // Small score for placement
                }
                
                updateBoardDisplay(); 
                handleMove(true); // Reset inactivity timer

                // 3. Check if all blocks in the set are used, and generate new ones
                if (currentBlockSet.every(block => block === null)) {
                    generateNewBlockSet();
                }

            } else {
                // Placement failed
                // handleMove(false); // Do not reset timer if placement failed
            }
            
            currentDraggingBlock = null;
            
            // 4. Check for Game Over condition
            if (checkGameOverCondition()) {
                handleGameOver();
            }
        }
        
        // --- Status Image Functions (Korean Filenames) ---

        /** Shows a status image and hides it after a duration */
        function showImage(fileName, duration = 1500) {
            statusImage.src = fileName; 
            statusImage.classList.add('visible');

            setTimeout(() => {
                statusImage.classList.remove('visible');
            }, duration);
        }

        /** Checks for inactivity and displays '잠.png' (30 seconds idle) */
        function checkInactivity() {
            if (Date.now() - lastMoveTime > SLEEP_TIMEOUT) {
                showImage('잠.png', 5000); 
            }
        }

        /** Resets the inactivity timer */
        function resetInactivityTimer() {
            lastMoveTime = Date.now();
            clearTimeout(sleepTimer);
            sleepTimer = setTimeout(checkInactivity, SLEEP_TIMEOUT);
        }
        
        // --- Game Event Triggers ---

        function handleMove(isSuccessfulMove) {
            if (isSuccessfulMove) {
                resetInactivityTimer();
            }
        }

        function handleCombo(isCombo, newScore) {
            if (isCombo) {
                comboCount++;
                // Display '행복.png' on combo
                showImage('행복.png', 1000); 
            } else {
                comboCount = 0; // Combo streak broken
            }
            
            score = newScore; 
            currentScoreElement.textContent = score;

            if (score > highScore) {
                handleNewRecord();
            }
        }

        function handleNewRecord() {
            highScore = score;
            localStorage.setItem('dulmungBlastHighScore', highScore);
            highScoreElement.textContent = highScore;
            // Display '신남.png' on new high score
            showImage('신남.png', 2000); 
        }

        function handleGameOver() {
            clearTimeout(sleepTimer);
            
            // Display '추움.png' on game over
            showImage('추움.png', 3000); 
            
            // Disable further moves and display final score
            gameBoard.removeEventListener('drop', handleBoardDrop);
            previewArea.querySelectorAll('.block-preview').forEach(b => b.draggable = false);
        }

        // --- Game Start Function ---
        function startGame() {
            score = 0;
            currentScoreElement.textContent = score;
            comboCount = 0;
            
            createBoard();
            updateBoardDisplay(); 
            generateNewBlockSet();
            
            resetInactivityTimer();
        }
        
        // Initialize game on page load
        document.addEventListener('DOMContentLoaded', startGame);
        
    </script>
</body>
</html>
