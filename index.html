        // --- Game Configuration (No change) ---
        const ROWS = 8;
        const COLS = 9;
        const CELL_COLORS = ['block-white', 'block-black', 'block-gray'];
        const SLEEP_TIMEOUT = 30000; // 30 seconds for '잠.png'

        // Define Block Shapes (No change)
        const BLOCK_SHAPES_DATA = [
            { id: 1, color: 'block-white', shape: [[1, 1, 1, 1]] }, // 1x4 line
            { id: 2, color: 'block-black', shape: [[1], [1], [1]] }, // 3x1 line
            { id: 3, color: 'block-gray', shape: [[1, 1], [1, 1]] }, // 2x2 square
            { id: 4, color: 'block-white', shape: [[1, 0], [1, 0], [1, 1]] }, // L shape
            { id: 5, color: 'block-black', shape: [[1, 1, 1], [0, 1, 0]] }, // T shape
            { id: 6, color: 'block-gray', shape: [[1, 1, 1]] }, // 1x3 line
            { id: 7, color: 'block-white', shape: [[1, 1]] }, // 1x2 line
            { id: 8, color: 'block-black', shape: [[1]] }, // 1x1 block
            { id: 9, color: 'block-gray', shape: [[1, 1, 1], [1, 0, 0], [1, 0, 0]] }, // Large L
        ];

        // --- DOM Elements (No change) ---
        const gameBoard = document.getElementById('game-board');
        const statusImage = document.getElementById('status-image');
        const currentScoreElement = document.getElementById('current-score');
        const highScoreElement = document.getElementById('high-score');
        const previewArea = document.getElementById('preview-area');

        // --- Game State Variables ---
        let board = []; 
        let score = 0;
        let highScore = localStorage.getItem('dulmungBlastHighScore') || 0;
        let lastMoveTime = Date.now();
        let sleepTimer = null;
        let comboCount = 0;
        let currentBlockSet = []; 
        
        // **NEW** Variable for touch selection
        let currentSelectedBlock = null; 
        let lastTouchTime = 0; // For double-tap detection

        highScoreElement.textContent = highScore;

        // --- Utility Functions (No change) ---
        function generateBlock() { /* ... function body ... */
            const randomIndex = Math.floor(Math.random() * BLOCK_SHAPES_DATA.length);
            return { ...BLOCK_SHAPES_DATA[randomIndex] };
        }
        function drawPreviewBlock(element, shapeData) { /* ... function body ... */
            element.innerHTML = '';
            
            const shapeDiv = document.createElement('div');
            shapeDiv.classList.add('block-shape');
            
            const rows = shapeData.shape.length;
            const cols = shapeData.shape[0].length;
            
            shapeDiv.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            shapeDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const blockPart = document.createElement('div');
                    blockPart.classList.add('block-part');
                    if (shapeData.shape[r][c] === 1) {
                        blockPart.classList.add(shapeData.color);
                    }
                    shapeDiv.appendChild(blockPart);
                }
            }
            element.appendChild(shapeDiv);
        }

        // --- Game Core Functions (Mostly unchanged, except for event listeners) ---

        function createBoard() { /* ... function body ... */
            gameBoard.innerHTML = '';
            board = Array(ROWS).fill(0).map(() => Array(COLS).fill(0)); 
            
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    // **MODIFIED:** Add click listener to the board cells
                    cell.addEventListener('click', handleBoardClick);
                    gameBoard.appendChild(cell);
                }
            }
        }
        
        function updateBoardDisplay() { /* ... function body ... */
            const cells = gameBoard.querySelectorAll('.cell');
            cells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                const blockType = board[r][c];
                
                CELL_COLORS.forEach(color => cell.classList.remove(color));

                if (blockType > 0) {
                    cell.classList.add(CELL_COLORS[blockType - 1]);
                }
            });
        }
        
        function generateNewBlockSet() { /* ... function body ... */
            previewArea.innerHTML = '';
            currentBlockSet = [];
            currentSelectedBlock = null; // Clear selection on new set

            for (let i = 0; i < 3; i++) {
                const blockData = generateBlock();
                currentBlockSet.push(blockData);

                const previewElement = document.createElement('div');
                previewElement.classList.add('block-preview');
                previewElement.id = `preview-${i}`;
                
                // Store block data in dataset
                previewElement.dataset.index = i;
                previewElement.dataset.shape = JSON.stringify(blockData.shape);
                previewElement.dataset.color = blockData.color;
                
                drawPreviewBlock(previewElement, blockData);

                // **MODIFIED:** Use touchstart for double-tap detection
                previewElement.addEventListener('touchstart', handlePreviewTouchStart);
                previewArea.appendChild(previewElement);
            }
        }
        
        function attemptPlacement(startRow, startCol, blockData) { /* ... function body ... */
            const shape = blockData.shape;
            const rows = shape.length;
            const cols = shape[0].length;
            const colorIndex = CELL_COLORS.indexOf(blockData.color) + 1;

            // 1. Check for boundaries and collisions
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (shape[r][c] === 1) {
                        const boardRow = startRow + r;
                        const boardCol = startCol + c;

                        if (boardRow >= ROWS || boardRow < 0 || boardCol >= COLS || boardCol < 0 || board[boardRow][boardCol] !== 0) {
                            return false; 
                        }
                    }
                }
            }

            // 2. Place the block
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (shape[r][c] === 1) {
                        board[startRow + r][startCol + c] = colorIndex;
                    }
                }
            }
            return true;
        }
        
        function checkAndClearLines() { /* ... function body ... */
            let clearedCount = 0;
            const linesToClear = [];

            // Check Rows
            for (let r = 0; r < ROWS; r++) {
                if (board[r].every(cell => cell !== 0)) {
                    linesToClear.push({ type: 'row', index: r });
                }
            }

            // Check Columns
            for (let c = 0; c < COLS; c++) {
                let isFull = true;
                for (let r = 0; r < ROWS; r++) {
                    if (board[r][c] === 0) {
                        isFull = false;
                        break;
                    }
                }
                if (isFull && !linesToClear.some(l => l.type === 'col' && l.index === c)) {
                    linesToClear.push({ type: 'col', index: c });
                }
            }
            
            // Clear the lines
            linesToClear.forEach(line => {
                clearedCount++;
                if (line.type === 'row') {
                    board[line.index].fill(0);
                } else if (line.type === 'col') {
                    for (let r = 0; r < ROWS; r++) {
                        board[r][line.index] = 0;
                    }
                }
            });

            return clearedCount;
        }

        function checkGameOverCondition() { /* ... function body ... */
            for (const blockData of currentBlockSet) {
                if (blockData) {
                    const shape = blockData.shape;
                    const rows = shape.length;
                    const cols = shape[0].length;
                    
                    for (let r = 0; r <= ROWS - rows; r++) {
                        for (let c = 0; c <= COLS - cols; c++) {
                            
                            let fits = true;
                            for (let br = 0; br < rows; br++) {
                                for (let bc = 0; bc < cols; bc++) {
                                    if (shape[br][bc] === 1) {
                                        if (board[r + br][c + bc] !== 0) {
                                            fits = false;
                                            break;
                                        }
                                    }
                                }
                                if (!fits) break;
                            }
                            if (fits) {
                                return false; 
                            }
                        }
                    }
                }
            }

            if (currentBlockSet.some(block => block !== null)) {
                return true;
            }

            return false;
        }
        
        // --- Event Handlers (New Touch Logic) ---

        // Function to remove selection from all previews
        function deselectAllPreviews() {
            previewArea.querySelectorAll('.block-preview').forEach(el => {
                el.style.border = '2px solid #666'; 
            });
        }
        
        /** Handle touchstart on preview block (used for double-tap selection) */
        function handlePreviewTouchStart(event) {
            const now = Date.now();
            const timeDiff = now - lastTouchTime;
            lastTouchTime = now;
            
            const previewElement = event.currentTarget;
            if (previewElement.classList.contains('empty')) return;

            // Double tap detected (e.g., within 300ms)
            if (timeDiff < 300) {
                // Deselect previous block
                deselectAllPreviews();
                
                // Select this block
                currentSelectedBlock = {
                    index: parseInt(previewElement.dataset.index),
                    shape: JSON.parse(previewElement.dataset.shape),
                    color: previewElement.dataset.color
                };
                previewElement.style.border = '4px solid gold'; // Visual feedback for selection
                
                resetInactivityTimer();
                
                // Prevent further touches/clicks on this element for a moment
                event.preventDefault(); 
            } else {
                // Single tap - treat as a regular tap/click
            }
        }

        /** Handle click/tap on the game board (attempt to place selected block) */
        function handleBoardClick(event) {
            if (!currentSelectedBlock) return; // No block selected

            const targetCell = event.currentTarget.closest('.cell');
            if (!targetCell) return;
            
            const startRow = parseInt(targetCell.dataset.row);
            const startCol = parseInt(targetCell.dataset.col);

            const blockData = currentSelectedBlock;

            // Attempt to place the block
            const placementSuccessful = attemptPlacement(startRow, startCol, blockData);

            if (placementSuccessful) {
                // 1. Mark block as placed and visually remove it
                const placedBlockIndex = blockData.index;
                currentBlockSet[placedBlockIndex] = null;
                const previewElement = document.getElementById(`preview-${placedBlockIndex}`);
                previewElement.classList.add('empty');
                previewElement.removeEventListener('touchstart', handlePreviewTouchStart);
                previewElement.innerHTML = '';
                
                // Deselect the block
                deselectAllPreviews();
                currentSelectedBlock = null;
                
                // 2. Check for cleared lines and combos
                const clearedLines = checkAndClearLines(); 
                let isCombo = clearedLines > 0;
                
                if (isCombo) {
                    const newScore = score + (clearedLines * 10) + (comboCount * 5); 
                    handleCombo(true, newScore); 
                } else {
                    handleCombo(false, score + 1); 
                }
                
                updateBoardDisplay(); 
                handleMove(true); 

                // 3. Check if all blocks in the set are used, and generate new ones
                if (currentBlockSet.every(block => block === null)) {
                    generateNewBlockSet();
                }

            } else {
                // Placement failed: Deselect the block to encourage re-selection/re-placement attempt
                deselectAllPreviews();
                currentSelectedBlock = null;
                // Optionally show a "Placement Failed" visual feedback
            }
            
            // 4. Check for Game Over condition
            if (checkGameOverCondition()) {
                handleGameOver();
            }
        }
        
        // --- Status Image Functions (No change) ---
        function showImage(fileName, duration = 1500) { /* ... function body ... */
            statusImage.src = fileName; 
            statusImage.classList.add('visible');

            setTimeout(() => {
                statusImage.classList.remove('visible');
            }, duration);
        }
        function checkInactivity() { /* ... function body ... */
            if (Date.now() - lastMoveTime > SLEEP_TIMEOUT) {
                showImage('잠.png', 5000); 
            }
        }
        function resetInactivityTimer() { /* ... function body ... */
            lastMoveTime = Date.now();
            clearTimeout(sleepTimer);
            sleepTimer = setTimeout(checkInactivity, SLEEP_TIMEOUT);
        }
        
        // --- Game Event Triggers (No change) ---

        function handleMove(isSuccessfulMove) { /* ... function body ... */
            if (isSuccessfulMove) {
                resetInactivityTimer();
            }
        }
        function handleCombo(isCombo, newScore) { /* ... function body ... */
            if (isCombo) {
                comboCount++;
                showImage('행복.png', 1000); 
            } else {
                comboCount = 0; 
            }
            
            score = newScore; 
            currentScoreElement.textContent = score;

            if (score > highScore) {
                handleNewRecord();
            }
        }
        function handleNewRecord() { /* ... function body ... */
            highScore = score;
            localStorage.setItem('dulmungBlastHighScore', highScore);
            highScoreElement.textContent = highScore;
            showImage('신남.png', 2000); 
        }

        function handleGameOver() { /* ... function body ... */
            clearTimeout(sleepTimer);
            
            showImage('추움.png', 3000); 
            
            // **MODIFIED:** Disable touch/click listeners
            gameBoard.querySelectorAll('.cell').forEach(cell => {
                cell.removeEventListener('click', handleBoardClick);
            });
            previewArea.querySelectorAll('.block-preview').forEach(b => {
                b.removeEventListener('touchstart', handlePreviewTouchStart);
            });
        }

        // --- Game Start Function ---
        function startGame() { /* ... function body ... */
            score = 0;
            currentScoreElement.textContent = score;
            comboCount = 0;
            
            createBoard(); // This adds the 'click' listener to cells
            updateBoardDisplay(); 
            generateNewBlockSet(); // This adds the 'touchstart' listener to previews
            
            resetInactivityTimer();
        }
        
        // Initialize game on page load
        document.addEventListener('DOMContentLoaded', startGame);
        
    </script>
</body>
</html>
